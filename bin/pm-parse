#!/usr/bin/env bash
# pm-parse - Parse PubMed XML to JSONL
# Usage: cat articles.xml | pm-parse [--verbose] > articles.jsonl

set -euo pipefail

# Source common functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/pm-common.sh
source "${SCRIPT_DIR}/../lib/pm-common.sh"

# Check dependencies
require_commands xml2

show_help() {
    cat << 'EOF'
pm-parse - Parse PubMed XML to JSONL

Usage: cat articles.xml | pm-parse [OPTIONS] > articles.jsonl
       zcat articles.xml.gz | pm-parse [OPTIONS] > articles.jsonl

Options:
  -v, --verbose  Show progress on stderr
  -h, --help     Show this help message

Output:
  One JSON object per line (JSONL format) with fields:
    pmid, title, authors, journal, year, doi, abstract

Examples:
  # Parse XML file
  cat pubmed.xml | pm-parse > articles.jsonl

  # Parse compressed baseline file
  zcat pubmed25n0001.xml.gz | pm-parse > articles.jsonl

  # With progress output
  cat pubmed.xml | pm-parse --verbose > articles.jsonl 2>progress.log
EOF
    exit 0
}

# Parse arguments
VERBOSE=0
while [[ $# -gt 0 ]]; do
    case "$1" in
        --verbose|-v)
            VERBOSE=1
            shift
            ;;
        --help|-h)
            show_help
            ;;
        *)
            die "Unknown option: $1. Use --help for usage."
            ;;
    esac
done

# Process XML using xml2 and awk (streaming - no memory buffering)
xml2 2>/dev/null | awk -v verbose="$VERBOSE" '
BEGIN {
    # Track current article data
    pmid = ""
    title = ""
    article_count = 0
    journal = ""
    year = ""
    doi = ""
    abstract = ""

    # Author handling
    author_count = 0
    current_lastname = ""
    current_forename = ""

    # Track if we are inside a DOI ArticleId
    in_doi_id = 0

    # Abstract section handling
    abstract_section_count = 0
    current_abstract_label = ""
}

# New PubmedArticle starts
/^\/PubmedArticleSet\/PubmedArticle$/ || /^\/PubmedArticle$/ {
    # Output previous article if we have data
    if (pmid != "") {
        output_article()
    }
    # Reset for new article
    pmid = ""
    title = ""
    journal = ""
    year = ""
    doi = ""
    abstract = ""
    author_count = 0
    current_lastname = ""
    current_forename = ""
    in_doi_id = 0
    abstract_section_count = 0
    current_abstract_label = ""
    delete abstract_sections
    delete abstract_section_labels
    next
}

# Extract PMID
/\/MedlineCitation\/PMID=/ {
    split($0, parts, "=")
    pmid = parts[2]
    next
}

# Extract title (append to handle xml2 splitting on embedded newlines)
/\/Article\/ArticleTitle=/ {
    text = substr($0, index($0, "=") + 1)
    if (title == "") {
        title = text
    } else {
        title = title "\n" text
    }
    next
}

# Extract journal (append to handle xml2 splitting on embedded newlines)
/\/Journal\/Title=/ {
    text = substr($0, index($0, "=") + 1)
    if (journal == "") {
        journal = text
    } else {
        journal = journal "\n" text
    }
    next
}

# Extract year from PubDate/Year
/\/PubDate\/Year=/ {
    if (year == "") {  # Take first year only
        split($0, parts, "=")
        year = parts[2]
    }
    next
}

# Extract year from MedlineDate (format: "YYYY Mon-Mon" or "YYYY Mon")
/\/PubDate\/MedlineDate=/ {
    if (year == "") {
        val = substr($0, index($0, "=") + 1)
        # Extract first 4-digit year
        if (match(val, /[0-9][0-9][0-9][0-9]/)) {
            year = substr(val, RSTART, 4)
        }
    }
    next
}

# Track DOI ArticleId
/\/ArticleId\/@IdType=doi/ {
    in_doi_id = 1
    next
}

# Extract DOI value
/\/ArticleIdList\/ArticleId=/ {
    if (in_doi_id == 1) {
        doi = substr($0, index($0, "=") + 1)
        in_doi_id = 0
    }
    next
}

# Reset DOI tracking when new ArticleId starts
/\/ArticleIdList\/ArticleId$/ {
    in_doi_id = 0
    next
}

# Capture abstract section label (comes before the text)
/\/Abstract\/AbstractText\/@Label=/ {
    current_abstract_label = substr($0, index($0, "=") + 1)
    next
}

# Extract abstract text (all AbstractText elements joined with space)
# Also store sections with labels for structured output
/\/Abstract\/AbstractText=/ {
    text = substr($0, index($0, "=") + 1)
    if (abstract == "") {
        abstract = text
    } else {
        abstract = abstract " " text
    }

    # Store section with label if present
    if (current_abstract_label != "") {
        abstract_section_count++
        abstract_section_labels[abstract_section_count] = current_abstract_label
        abstract_sections[abstract_section_count] = text
    }
    current_abstract_label = ""
    next
}

# Author lastname
/\/Author\/LastName=/ {
    current_lastname = substr($0, index($0, "=") + 1)
    next
}

# Author forename
/\/Author\/ForeName=/ {
    current_forename = substr($0, index($0, "=") + 1)
    next
}

# New author starts (save previous if exists)
/\/AuthorList\/Author$/ {
    if (current_lastname != "") {
        author_count++
        # Only add space if forename exists (avoid trailing whitespace)
        if (current_forename != "") {
            authors[author_count] = current_lastname " " current_forename
        } else {
            authors[author_count] = current_lastname
        }
    }
    current_lastname = ""
    current_forename = ""
    next
}

END {
    # Output last article (output_article handles pending author)
    if (pmid != "") {
        output_article()
    }
}

function json_escape(s) {
    gsub(/\\/, "\\\\", s)
    gsub(/"/, "\\\"", s)
    gsub(/\n/, "\\n", s)
    gsub(/\r/, "\\r", s)
    gsub(/\t/, "\\t", s)
    return s
}

function output_article() {
    # Save current author if exists
    if (current_lastname != "") {
        author_count++
        # Only add space if forename exists (avoid trailing whitespace)
        if (current_forename != "") {
            authors[author_count] = current_lastname " " current_forename
        } else {
            authors[author_count] = current_lastname
        }
        current_lastname = ""
        current_forename = ""
    }

    # Build authors JSON array
    authors_json = "["
    for (i = 1; i <= author_count; i++) {
        if (i > 1) authors_json = authors_json ","
        authors_json = authors_json "\"" json_escape(authors[i]) "\""
    }
    authors_json = authors_json "]"

    # Build abstract_sections JSON array (only if labels exist)
    abstract_sections_json = ""
    if (abstract_section_count > 0) {
        abstract_sections_json = "["
        for (i = 1; i <= abstract_section_count; i++) {
            if (i > 1) abstract_sections_json = abstract_sections_json ","
            abstract_sections_json = abstract_sections_json "{\"label\":\"" json_escape(abstract_section_labels[i]) "\",\"text\":\"" json_escape(abstract_sections[i]) "\"}"
        }
        abstract_sections_json = abstract_sections_json "]"
    }

    # Output JSON
    printf "{\"pmid\":\"%s\"", json_escape(pmid)
    if (title != "") printf ",\"title\":\"%s\"", json_escape(title)
    if (author_count > 0) printf ",\"authors\":%s", authors_json
    if (journal != "") printf ",\"journal\":\"%s\"", json_escape(journal)
    if (year != "") printf ",\"year\":\"%s\"", json_escape(year)
    if (doi != "") printf ",\"doi\":\"%s\"", json_escape(doi)
    if (abstract != "") printf ",\"abstract\":\"%s\"", json_escape(abstract)
    if (abstract_sections_json != "") printf ",\"abstract_sections\":%s", abstract_sections_json
    print "}"

    # Verbose output to stderr
    article_count++
    if (verbose == 1) {
        printf "Parsed article %d: PMID %s\n", article_count, pmid > "/dev/stderr"
    }

    # Reset arrays
    delete authors
    author_count = 0
    delete abstract_sections
    delete abstract_section_labels
    abstract_section_count = 0
}
'
