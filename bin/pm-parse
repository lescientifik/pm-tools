#!/usr/bin/env bash
# pm-parse - Parse PubMed XML to JSONL
# Usage: cat articles.xml | pm-parse [--verbose] > articles.jsonl

set -euo pipefail

# Source common functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/pm-common.sh
source "${SCRIPT_DIR}/../lib/pm-common.sh"

# Check dependencies
require_commands xml2

# Use mawk if available (1.8x faster than gawk), otherwise fall back to awk
if command -v mawk &>/dev/null; then
    AWK_CMD="mawk"
else
    AWK_CMD="awk"
fi

show_help() {
    cat << 'EOF'
pm-parse - Parse PubMed XML to JSONL

Usage: cat articles.xml | pm-parse [OPTIONS] > articles.jsonl
       zcat articles.xml.gz | pm-parse [OPTIONS] > articles.jsonl

Options:
  -v, --verbose  Show progress on stderr
  -h, --help     Show this help message

Output:
  One JSON object per line (JSONL format) with fields:
    pmid, title, authors, journal, year, date, doi, pmcid, abstract

Examples:
  # Parse XML file
  cat pubmed.xml | pm-parse > articles.jsonl

  # Parse compressed baseline file
  zcat pubmed25n0001.xml.gz | pm-parse > articles.jsonl

  # With progress output
  cat pubmed.xml | pm-parse --verbose > articles.jsonl 2>progress.log
EOF
    exit 0
}

# Parse arguments
VERBOSE=0
while [[ $# -gt 0 ]]; do
    case "$1" in
        --verbose|-v)
            VERBOSE=1
            shift
            ;;
        --help|-h)
            show_help
            ;;
        *)
            die "Unknown option: $1. Use --help for usage."
            ;;
    esac
done

# Process XML using xml2, grep prefilter, and awk (streaming - no memory buffering)
# The grep prefilter reduces 4.5M lines to ~1M by keeping only relevant paths,
# improving performance from ~1000 to ~6000 articles/sec (Unix philosophy: right tool for each job)
# Note: { grep ... || true; } handles empty input gracefully (grep returns 1 when no matches)
# shellcheck disable=SC2016 # Single quotes intentional for awk script
xml2 2>/dev/null | { grep -E '(PubmedArticle$|PMID=|ArticleTitle=|Journal/Title=|PubDate/|ArticleId|AbstractText|LastName=|ForeName=|Author$)' || true; } | $AWK_CMD -v verbose="$VERBOSE" '
BEGIN {
    # Track current article data
    pmid = ""
    title = ""
    article_count = 0
    journal = ""
    year = ""
    month = ""
    day = ""
    season = ""
    medline_date = ""
    doi = ""
    abstract = ""

    # Author handling
    author_count = 0
    current_lastname = ""
    current_forename = ""

    # Track if we are inside a DOI or PMC ArticleId
    in_doi_id = 0
    in_pmc_id = 0
    pmcid = ""

    # Abstract section handling
    abstract_section_count = 0
    current_abstract_label = ""
}

# New PubmedArticle starts
/^\/PubmedArticleSet\/PubmedArticle$/ || /^\/PubmedArticle$/ {
    # Output previous article if we have data
    if (pmid != "") {
        output_article()
    }
    # Reset for new article
    pmid = ""
    title = ""
    journal = ""
    year = ""
    month = ""
    day = ""
    season = ""
    medline_date = ""
    doi = ""
    pmcid = ""
    abstract = ""
    author_count = 0
    current_lastname = ""
    current_forename = ""
    in_doi_id = 0
    in_pmc_id = 0
    abstract_section_count = 0
    current_abstract_label = ""
    delete abstract_sections
    delete abstract_section_labels
    next
}

# Extract PMID
/\/MedlineCitation\/PMID=/ {
    split($0, parts, "=")
    pmid = parts[2]
    next
}

# Extract title (append to handle xml2 splitting on embedded newlines)
/\/Article\/ArticleTitle=/ {
    text = substr($0, index($0, "=") + 1)
    if (title == "") {
        title = text
    } else {
        title = title "\n" text
    }
    next
}

# Extract journal (append to handle xml2 splitting on embedded newlines)
/\/Journal\/Title=/ {
    text = substr($0, index($0, "=") + 1)
    if (journal == "") {
        journal = text
    } else {
        journal = journal "\n" text
    }
    next
}

# Extract year from PubDate/Year
/\/PubDate\/Year=/ {
    if (year == "") {  # Take first year only
        split($0, parts, "=")
        year = parts[2]
    }
    next
}

# Extract month from PubDate/Month
/\/PubDate\/Month=/ {
    if (month == "") {
        month = substr($0, index($0, "=") + 1)
    }
    next
}

# Extract day from PubDate/Day
/\/PubDate\/Day=/ {
    if (day == "") {
        day = substr($0, index($0, "=") + 1)
    }
    next
}

# Extract season from PubDate/Season
/\/PubDate\/Season=/ {
    if (season == "") {
        season = substr($0, index($0, "=") + 1)
    }
    next
}

# Extract year from MedlineDate (format: "YYYY Mon-Mon" or "YYYY Mon")
/\/PubDate\/MedlineDate=/ {
    val = substr($0, index($0, "=") + 1)
    if (year == "") {
        # Extract first 4-digit year
        if (match(val, /[0-9][0-9][0-9][0-9]/)) {
            year = substr(val, RSTART, 4)
        }
    }
    # Store full MedlineDate for later parsing
    if (medline_date == "") {
        medline_date = val
    }
    next
}

# Track DOI ArticleId
/\/ArticleId\/@IdType=doi/ {
    in_doi_id = 1
    next
}

# Track PMC ArticleId
/\/ArticleId\/@IdType=pmc/ {
    in_pmc_id = 1
    next
}

# Extract DOI or PMCID value
/\/ArticleIdList\/ArticleId=/ {
    if (in_doi_id == 1) {
        doi = substr($0, index($0, "=") + 1)
        in_doi_id = 0
    }
    if (in_pmc_id == 1) {
        pmcid = substr($0, index($0, "=") + 1)
        in_pmc_id = 0
    }
    next
}

# Reset DOI/PMC tracking when new ArticleId starts
/\/ArticleIdList\/ArticleId$/ {
    in_doi_id = 0
    in_pmc_id = 0
    next
}

# Capture abstract section label (comes before the text)
/\/Abstract\/AbstractText\/@Label=/ {
    current_abstract_label = substr($0, index($0, "=") + 1)
    next
}

# Extract abstract text (all AbstractText elements joined with space)
# Also store sections with labels for structured output
/\/Abstract\/AbstractText=/ {
    text = substr($0, index($0, "=") + 1)
    if (abstract == "") {
        abstract = text
    } else {
        abstract = abstract " " text
    }

    # Store section with label if present
    if (current_abstract_label != "") {
        abstract_section_count++
        abstract_section_labels[abstract_section_count] = current_abstract_label
        abstract_sections[abstract_section_count] = text
    }
    current_abstract_label = ""
    next
}

# Author lastname
/\/Author\/LastName=/ {
    current_lastname = substr($0, index($0, "=") + 1)
    next
}

# Author forename
/\/Author\/ForeName=/ {
    current_forename = substr($0, index($0, "=") + 1)
    next
}

# New author starts (save previous if exists)
/\/AuthorList\/Author$/ {
    if (current_lastname != "") {
        author_count++
        # Only add space if forename exists (avoid trailing whitespace)
        if (current_forename != "") {
            authors[author_count] = current_lastname " " current_forename
        } else {
            authors[author_count] = current_lastname
        }
    }
    current_lastname = ""
    current_forename = ""
    next
}

END {
    # Output last article (output_article handles pending author)
    if (pmid != "") {
        output_article()
    }
}

function json_escape(s) {
    gsub(/\\/, "\\\\", s)
    gsub(/"/, "\\\"", s)
    gsub(/\n/, "\\n", s)
    gsub(/\r/, "\\r", s)
    gsub(/\t/, "\\t", s)
    return s
}

# Convert text month name to 2-digit number
function month_to_num(m) {
    m = tolower(m)
    if (m == "jan" || m == "01" || m == "1") return "01"
    if (m == "feb" || m == "02" || m == "2") return "02"
    if (m == "mar" || m == "03" || m == "3") return "03"
    if (m == "apr" || m == "04" || m == "4") return "04"
    if (m == "may" || m == "05" || m == "5") return "05"
    if (m == "jun" || m == "06" || m == "6") return "06"
    if (m == "jul" || m == "07" || m == "7") return "07"
    if (m == "aug" || m == "08" || m == "8") return "08"
    if (m == "sep" || m == "09" || m == "9") return "09"
    if (m == "oct" || m == "10") return "10"
    if (m == "nov" || m == "11") return "11"
    if (m == "dec" || m == "12") return "12"
    return ""
}

# Map season to quarter start month
function season_to_month(s) {
    s = tolower(s)
    if (s == "spring") return "03"
    if (s == "summer") return "06"
    if (s == "fall" || s == "autumn") return "09"
    if (s == "winter") return "12"
    return ""
}

# Parse MedlineDate to extract best date
# Returns ISO date string (YYYY, YYYY-MM, or YYYY-MM-DD)
function parse_medline_date(md,    y, m, d, month_str, rest) {
    # Extract year first
    if (!match(md, /[0-9][0-9][0-9][0-9]/)) {
        return ""
    }
    y = substr(md, RSTART, 4)

    # Try to find month after year and space: "YYYY Mon..."
    rest = substr(md, RSTART + 4)
    if (match(rest, /^ ([A-Za-z][A-Za-z][A-Za-z])/)) {
        month_str = substr(rest, RSTART + 1, 3)
        m = month_to_num(month_str)
        if (m != "") {
            # Try to find day after month: "YYYY Mon D" or "YYYY Mon DD"
            rest = substr(rest, RSTART + 4)
            if (match(rest, /^[ ]*([0-9][0-9]?)/)) {
                d = substr(rest, RSTART, RLENGTH)
                gsub(/[ ]/, "", d)
                return y "-" m "-" sprintf("%02d", d)
            }
            return y "-" m
        }
    }

    return y
}

# Build ISO date from structured fields or MedlineDate
function build_date() {
    if (year == "") return ""

    # If we have MedlineDate, parse it for best date
    if (medline_date != "") {
        return parse_medline_date(medline_date)
    }

    # Handle Season -> map to quarter start month
    if (season != "") {
        m = season_to_month(season)
        if (m != "") return year "-" m
        return year
    }

    # Handle structured Month/Day
    if (month != "") {
        m = month_to_num(month)
        if (m == "") m = month  # Use as-is if already numeric format
        if (day != "") {
            return year "-" m "-" sprintf("%02d", day)
        }
        return year "-" m
    }

    return year
}

function output_article(    date) {
    # Save current author if exists
    if (current_lastname != "") {
        author_count++
        # Only add space if forename exists (avoid trailing whitespace)
        if (current_forename != "") {
            authors[author_count] = current_lastname " " current_forename
        } else {
            authors[author_count] = current_lastname
        }
        current_lastname = ""
        current_forename = ""
    }

    # Build authors JSON array
    authors_json = "["
    for (i = 1; i <= author_count; i++) {
        if (i > 1) authors_json = authors_json ","
        authors_json = authors_json "\"" json_escape(authors[i]) "\""
    }
    authors_json = authors_json "]"

    # Build abstract_sections JSON array (only if labels exist)
    abstract_sections_json = ""
    if (abstract_section_count > 0) {
        abstract_sections_json = "["
        for (i = 1; i <= abstract_section_count; i++) {
            if (i > 1) abstract_sections_json = abstract_sections_json ","
            abstract_sections_json = abstract_sections_json "{\"label\":\"" json_escape(abstract_section_labels[i]) "\",\"text\":\"" json_escape(abstract_sections[i]) "\"}"
        }
        abstract_sections_json = abstract_sections_json "]"
    }

    # Build date field
    date = build_date()

    # Output JSON
    printf "{\"pmid\":\"%s\"", json_escape(pmid)
    if (title != "") printf ",\"title\":\"%s\"", json_escape(title)
    if (author_count > 0) printf ",\"authors\":%s", authors_json
    if (journal != "") printf ",\"journal\":\"%s\"", json_escape(journal)
    if (year != "") printf ",\"year\":\"%s\"", json_escape(year)
    if (date != "") printf ",\"date\":\"%s\"", json_escape(date)
    if (doi != "") printf ",\"doi\":\"%s\"", json_escape(doi)
    if (pmcid != "") printf ",\"pmcid\":\"%s\"", json_escape(pmcid)
    if (abstract != "") printf ",\"abstract\":\"%s\"", json_escape(abstract)
    if (abstract_sections_json != "") printf ",\"abstract_sections\":%s", abstract_sections_json
    print "}"

    # Verbose output to stderr
    article_count++
    if (verbose == 1) {
        printf "Parsed article %d: PMID %s\n", article_count, pmid > "/dev/stderr"
    }

    # Reset arrays
    delete authors
    author_count = 0
    delete abstract_sections
    delete abstract_section_labels
    abstract_section_count = 0
}
'
