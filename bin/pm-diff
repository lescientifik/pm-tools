#!/usr/bin/env bash
# pm-diff - Compare two JSONL files by PMID (streaming JSONL output)
# Usage: pm-diff [OPTIONS] OLD_FILE NEW_FILE

set -euo pipefail

# Source common functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/pm-common.sh
source "${SCRIPT_DIR}/../lib/pm-common.sh"

# Check dependencies
require_commands jq

show_help() {
    cat << 'EOF'
pm-diff - Compare two JSONL files by PMID

Usage: pm-diff [OPTIONS] OLD_FILE NEW_FILE
       pm-diff [OPTIONS] OLD_FILE - < new.jsonl
       pm-diff [OPTIONS] - NEW_FILE < old.jsonl

Arguments:
  OLD_FILE    Baseline/reference JSONL file (or - for stdin)
  NEW_FILE    New/comparison JSONL file (or - for stdin)
  Note: At most one of OLD_FILE or NEW_FILE can be - (stdin)

Output: Streaming JSONL with one line per difference:
  {"pmid":"...","status":"added","article":{...}}
  {"pmid":"...","status":"removed","article":{...}}
  {"pmid":"...","status":"changed","old":{...},"new":{...}}

Options:
  -q, --quiet         Suppress output, just set exit code
  --ignore FIELDS     Ignore these fields when comparing (comma-separated)
  -h, --help          Show this help

Exit Codes:
  0    No differences (files are identical)
  1    Differences found
  2    Error (invalid arguments, file not found, malformed JSON)

Examples:
  # Stream differences as JSONL
  pm-diff baseline_v1.jsonl baseline_v2.jsonl

  # Get just added PMIDs
  pm-diff old.jsonl new.jsonl | jq -r 'select(.status=="added") | .pmid'

  # Summary counts
  pm-diff old.jsonl new.jsonl | jq -s 'group_by(.status) | map({(.[0].status): length}) | add'

  # Just check if identical (for scripts)
  pm-diff file1.jsonl file2.jsonl --quiet && echo "identical"

  # Ignore abstract changes
  pm-diff old.jsonl new.jsonl --ignore abstract
EOF
    exit 0
}

# Options
quiet=false
ignore_fields=""

# Positional arguments
old_file=""
new_file=""

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h)
            show_help
            ;;
        --quiet|-q)
            quiet=true
            shift
            ;;
        --ignore)
            shift
            ignore_fields="${1:-}"
            if [[ -z "$ignore_fields" ]]; then
                echo "Error: --ignore requires an argument" >&2
                exit 2
            fi
            shift
            ;;
        --ignore=*)
            ignore_fields="${1#*=}"
            shift
            ;;
        -)
            # Stdin marker - treat as positional argument
            if [[ -z "$old_file" ]]; then
                old_file="-"
            elif [[ -z "$new_file" ]]; then
                new_file="-"
            else
                echo "Error: Too many arguments" >&2
                exit 2
            fi
            shift
            ;;
        -*)
            echo "Error: Unknown option: $1" >&2
            exit 2
            ;;
        *)
            # Positional argument
            if [[ -z "$old_file" ]]; then
                old_file="$1"
            elif [[ -z "$new_file" ]]; then
                new_file="$1"
            else
                echo "Error: Too many arguments" >&2
                exit 2
            fi
            shift
            ;;
    esac
done

# Validate arguments
if [[ -z "$old_file" ]] || [[ -z "$new_file" ]]; then
    echo "Error: Two files required" >&2
    echo "Usage: pm-diff [OPTIONS] OLD_FILE NEW_FILE" >&2
    exit 2
fi

# Check both aren't stdin
if [[ "$old_file" == "-" ]] && [[ "$new_file" == "-" ]]; then
    echo "Error: Cannot use stdin (-) for both files" >&2
    exit 2
fi

# Validate files exist (unless stdin)
if [[ "$old_file" != "-" ]] && [[ ! -f "$old_file" ]]; then
    echo "Error: File does not exist: $old_file" >&2
    exit 2
fi

if [[ "$new_file" != "-" ]] && [[ ! -f "$new_file" ]]; then
    echo "Error: File does not exist: $new_file" >&2
    exit 2
fi

# Create temp directory for sorted files
tmpdir=$(mktemp -d)
trap 'rm -rf "$tmpdir"' EXIT

# =============================================================================
# Build jq filter for field exclusion (for comparison)
# =============================================================================
build_jq_filter() {
    if [[ -n "$ignore_fields" ]]; then
        # Exclude specified fields
        local del_jq=""
        IFS=',' read -ra fields <<< "$ignore_fields"
        for f in "${fields[@]}"; do
            f=$(echo "$f" | tr -d ' ')
            if [[ -n "$del_jq" ]]; then
                del_jq="$del_jq | "
            fi
            del_jq="${del_jq}del(.$f)"
        done
        echo "$del_jq"
    else
        echo "."
    fi
}

jq_filter=$(build_jq_filter)

# =============================================================================
# Preprocess files: normalize JSON, extract PMID, sort
# Output format: JSON with pmid, full, compare fields
# =============================================================================
preprocess_file() {
    local input="$1"
    local output="$2"
    local filter="$3"

    local input_source
    if [[ "$input" == "-" ]]; then
        input_source="/dev/stdin"
    else
        input_source="$input"
    fi

    # Process all lines with single jq invocation using -R (raw input) mode
    # Each line is read as string, parsed with try-fromjson, invalid lines skipped
    # This is much faster than spawning jq per line
    jq -Rc '
        # Try to parse JSON, skip if invalid
        try (fromjson) // empty |
        # Skip if no pmid
        select(.pmid != null) |
        # Build output object
        . as $full |
        {
            pmid: .pmid,
            full: ($full | tojson),
            compare: (($full | '"$filter"') | tojson)
        }
    ' < "$input_source" 2>/dev/null | sort -t$'\t' -k1,1 -s > "$output"
}

# =============================================================================
# Process with awk: merge sorted files, output JSONL differences
# =============================================================================
process_diff() {
    local old_sorted="$1"
    local new_sorted="$2"

    # Use awk to merge the two sorted streams
    # Use FILENAME to distinguish files (NR==FNR fails with empty first file)
    awk -v old_file="$old_sorted" -v new_file="$new_sorted" '
    BEGIN {
        has_diff = 0
    }

    # Extract pmid from JSON line
    function get_pmid(line) {
        if (match(line, /"pmid":"([^"]+)"/, arr)) {
            return arr[1]
        }
        return ""
    }

    # Load old file into associative arrays
    FILENAME == old_file {
        pmid = get_pmid($0)
        if (pmid != "") {
            old_full[pmid] = $0
            old_compare[pmid] = $0
            old_order[++old_count] = pmid
        }
        next
    }

    # Process new file
    FILENAME == new_file {
        pmid = get_pmid($0)
        if (pmid != "") {
            new_full[pmid] = $0
            new_compare[pmid] = $0
            new_order[++new_count] = pmid
            seen_in_new[pmid] = 1
        }
    }

    END {
        # Process all PMIDs from old file (removed or changed)
        for (i = 1; i <= old_count; i++) {
            pmid = old_order[i]
            if (!(pmid in seen_in_new)) {
                # Removed
                has_diff = 1
                # Extract the full JSON from old
                json = old_full[pmid]
                if (match(json, /"full":"(.*)",[ ]*"compare":/, arr)) {
                    full_escaped = arr[1]
                } else if (match(json, /"full":(.*),"compare":/, arr)) {
                    full_escaped = arr[1]
                }
                # Unescape the JSON string
                gsub(/\\\\/, "\\", full_escaped)
                gsub(/\\"/, "\"", full_escaped)
                print "{\"pmid\":\"" pmid "\",\"status\":\"removed\",\"article\":" full_escaped "}"
            } else {
                # Check if changed by comparing the compare JSONs
                old_cmp = old_compare[pmid]
                new_cmp = new_compare[pmid]

                # Extract compare values
                if (match(old_cmp, /"compare":"(.*)"$/, arr)) {
                    old_cmp_val = arr[1]
                } else if (match(old_cmp, /"compare":(.*)$/, arr)) {
                    old_cmp_val = arr[1]
                }
                if (match(new_cmp, /"compare":"(.*)"$/, arr)) {
                    new_cmp_val = arr[1]
                } else if (match(new_cmp, /"compare":(.*)$/, arr)) {
                    new_cmp_val = arr[1]
                }

                if (old_cmp_val != new_cmp_val) {
                    # Changed
                    has_diff = 1
                    # Extract full JSONs
                    if (match(old_full[pmid], /"full":"(.*)",[ ]*"compare":/, arr)) {
                        old_full_val = arr[1]
                    }
                    if (match(new_full[pmid], /"full":"(.*)",[ ]*"compare":/, arr)) {
                        new_full_val = arr[1]
                    }
                    gsub(/\\\\/, "\\", old_full_val)
                    gsub(/\\"/, "\"", old_full_val)
                    gsub(/\\\\/, "\\", new_full_val)
                    gsub(/\\"/, "\"", new_full_val)
                    print "{\"pmid\":\"" pmid "\",\"status\":\"changed\",\"old\":" old_full_val ",\"new\":" new_full_val "}"
                }
            }
        }

        # Process PMIDs only in new file (added)
        for (i = 1; i <= new_count; i++) {
            pmid = new_order[i]
            if (!(pmid in old_full)) {
                # Added
                has_diff = 1
                json = new_full[pmid]
                if (match(json, /"full":"(.*)",[ ]*"compare":/, arr)) {
                    full_escaped = arr[1]
                } else if (match(json, /"full":(.*),"compare":/, arr)) {
                    full_escaped = arr[1]
                }
                gsub(/\\\\/, "\\", full_escaped)
                gsub(/\\"/, "\"", full_escaped)
                print "{\"pmid\":\"" pmid "\",\"status\":\"added\",\"article\":" full_escaped "}"
            }
        }

        exit (has_diff ? 1 : 0)
    }
    ' "$old_sorted" "$new_sorted"
}

# =============================================================================
# Main execution
# =============================================================================

# Preprocess both files
preprocess_file "$old_file" "$tmpdir/old_sorted.jsonl" "$jq_filter"
preprocess_file "$new_file" "$tmpdir/new_sorted.jsonl" "$jq_filter"

# Run the diff
if [[ "$quiet" == true ]]; then
    # Just check for differences, no output
    process_diff "$tmpdir/old_sorted.jsonl" "$tmpdir/new_sorted.jsonl" > /dev/null
    exit_code=$?
else
    process_diff "$tmpdir/old_sorted.jsonl" "$tmpdir/new_sorted.jsonl"
    exit_code=$?
fi

exit $exit_code
