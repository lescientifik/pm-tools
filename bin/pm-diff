#!/usr/bin/env bash
# pm-diff - Compare two JSONL files by PMID
# Usage: pm-diff [OPTIONS] OLD_FILE NEW_FILE

set -euo pipefail

# Source common functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/pm-common.sh
source "${SCRIPT_DIR}/../lib/pm-common.sh"

# Check dependencies
require_commands jq

show_help() {
    cat << 'EOF'
pm-diff - Compare two JSONL files by PMID

Usage: pm-diff [OPTIONS] OLD_FILE NEW_FILE
       pm-diff [OPTIONS] OLD_FILE - < new.jsonl
       pm-diff [OPTIONS] - NEW_FILE < old.jsonl

Arguments:
  OLD_FILE    Baseline/reference JSONL file (or - for stdin)
  NEW_FILE    New/comparison JSONL file (or - for stdin)
  Note: At most one of OLD_FILE or NEW_FILE can be - (stdin)

Output Formats (--format):
  summary     Show counts only (default)
  detailed    Show all changes with field-level diffs
  added       List PMIDs that were added (one per line)
  removed     List PMIDs that were removed (one per line)
  changed     List PMIDs that were changed (one per line)
  all         List all PMIDs with differences (added + removed + changed)
  jsonl       Output changes as JSONL with full article data

Options:
  -f, --format FMT    Output format (see above)
  -q, --quiet         Suppress output, just set exit code
  --fields FIELDS     Compare only these fields (comma-separated)
                      Default: compare all fields
  --ignore FIELDS     Ignore these fields when comparing (comma-separated)
  -h, --help          Show this help

Exit Codes:
  0    No differences (files are identical)
  1    Differences found
  2    Error (invalid arguments, file not found, malformed JSON)

Examples:
  # Summary of changes
  pm-diff baseline_v1.jsonl baseline_v2.jsonl

  # Get list of new PMIDs for fetching
  pm-diff old.jsonl new.jsonl --format added | pm-fetch

  # Detailed view of what changed
  pm-diff old.jsonl new.jsonl --format detailed

  # Just check if identical (for scripts)
  pm-diff file1.jsonl file2.jsonl --quiet && echo "identical"

  # Compare only title and abstract
  pm-diff old.jsonl new.jsonl --fields pmid,title,abstract

  # Ignore abstract changes
  pm-diff old.jsonl new.jsonl --ignore abstract
EOF
    exit 0
}

# Options
output_format="summary"
quiet=false
fields_filter=""
ignore_fields=""

# Positional arguments
old_file=""
new_file=""

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h)
            show_help
            ;;
        --format|-f)
            shift
            output_format="${1:-}"
            if [[ -z "$output_format" ]]; then
                echo "Error: --format requires an argument" >&2
                exit 2
            fi
            shift
            ;;
        --format=*)
            output_format="${1#*=}"
            shift
            ;;
        -f*)
            output_format="${1#-f}"
            shift
            ;;
        --quiet|-q)
            quiet=true
            shift
            ;;
        --fields)
            shift
            fields_filter="${1:-}"
            if [[ -z "$fields_filter" ]]; then
                echo "Error: --fields requires an argument" >&2
                exit 2
            fi
            shift
            ;;
        --fields=*)
            fields_filter="${1#*=}"
            shift
            ;;
        --ignore)
            shift
            ignore_fields="${1:-}"
            if [[ -z "$ignore_fields" ]]; then
                echo "Error: --ignore requires an argument" >&2
                exit 2
            fi
            shift
            ;;
        --ignore=*)
            ignore_fields="${1#*=}"
            shift
            ;;
        -)
            # Stdin marker - treat as positional argument
            if [[ -z "$old_file" ]]; then
                old_file="-"
            elif [[ -z "$new_file" ]]; then
                new_file="-"
            else
                echo "Error: Too many arguments" >&2
                exit 2
            fi
            shift
            ;;
        -*)
            echo "Error: Unknown option: $1" >&2
            exit 2
            ;;
        *)
            # Positional argument
            if [[ -z "$old_file" ]]; then
                old_file="$1"
            elif [[ -z "$new_file" ]]; then
                new_file="$1"
            else
                echo "Error: Too many arguments" >&2
                exit 2
            fi
            shift
            ;;
    esac
done

# Validate arguments
if [[ -z "$old_file" ]] || [[ -z "$new_file" ]]; then
    echo "Error: Two files required" >&2
    echo "Usage: pm-diff [OPTIONS] OLD_FILE NEW_FILE" >&2
    exit 2
fi

# Check both aren't stdin
if [[ "$old_file" == "-" ]] && [[ "$new_file" == "-" ]]; then
    echo "Error: Cannot use stdin (-) for both files" >&2
    exit 2
fi

# Validate files exist (unless stdin)
if [[ "$old_file" != "-" ]] && [[ ! -f "$old_file" ]]; then
    echo "Error: File does not exist: $old_file" >&2
    exit 2
fi

if [[ "$new_file" != "-" ]] && [[ ! -f "$new_file" ]]; then
    echo "Error: File does not exist: $new_file" >&2
    exit 2
fi

# =============================================================================
# Load files into associative arrays
# =============================================================================

declare -A old_articles=()  # pmid -> normalized JSON line
declare -A new_articles=()

# Load a file into an associative array
# Args: $1 = file path (or - for stdin), $2 = array name reference
load_file() {
    local file="$1"
    local -n arr=$2
    local line pmid normalized

    local input_source
    if [[ "$file" == "-" ]]; then
        input_source="/dev/stdin"
    else
        input_source="$file"
    fi

    while IFS= read -r line || [[ -n "$line" ]]; do
        # Skip empty lines
        [[ -z "$line" ]] && continue

        # Extract PMID (handle jq parse errors gracefully)
        pmid=$(echo "$line" | jq -r '.pmid // empty' 2>/dev/null) || true
        if [[ -z "$pmid" ]]; then
            echo "Warning: Skipping line without valid PMID" >&2
            continue
        fi

        # Normalize JSON (sorted keys, compact)
        normalized=$(echo "$line" | jq -cS '.' 2>/dev/null) || true
        if [[ -z "$normalized" ]]; then
            echo "Warning: Skipping invalid JSON line" >&2
            continue
        fi

        # Check for duplicates
        if [[ -n "${arr[$pmid]:-}" ]]; then
            echo "Warning: Duplicate PMID $pmid, using last occurrence" >&2
        fi

        arr["$pmid"]="$normalized"
    done < "$input_source"
}

# Load both files
load_file "$old_file" old_articles
load_file "$new_file" new_articles

# =============================================================================
# Compare articles
# =============================================================================

# Build jq filter for field selection/exclusion
build_compare_json() {
    local json="$1"

    if [[ -n "$fields_filter" ]]; then
        # Include only specified fields
        # Convert "pmid,title" to "{pmid: .pmid, title: .title}"
        local fields_jq
        fields_jq=$(echo "$fields_filter" | tr ',' '\n' | while read -r f; do echo "$f: .$f"; done | paste -sd ',' -)
        echo "$json" | jq -cS "{$fields_jq}" 2>/dev/null || echo "$json"
    elif [[ -n "$ignore_fields" ]]; then
        # Exclude specified fields
        local del_paths
        del_paths=$(echo "$ignore_fields" | tr ',' '\n' | while read -r f; do echo "del(.$f)"; done | paste -sd ' | ' -)
        echo "$json" | jq -cS "$del_paths" 2>/dev/null || echo "$json"
    else
        # Compare all fields
        echo "$json"
    fi
}

declare -a added_pmids=()
declare -a removed_pmids=()
declare -a changed_pmids=()
declare -a unchanged_pmids=()

# Find removed and changed (iterate old)
for pmid in ${old_articles[@]+"${!old_articles[@]}"}; do
    if [[ -z "${new_articles[$pmid]:-}" ]]; then
        removed_pmids+=("$pmid")
    else
        # Compare with field filtering
        old_compare=$(build_compare_json "${old_articles[$pmid]}")
        new_compare=$(build_compare_json "${new_articles[$pmid]}")
        if [[ "$old_compare" != "$new_compare" ]]; then
            changed_pmids+=("$pmid")
        else
            unchanged_pmids+=("$pmid")
        fi
    fi
done

# Find added (iterate new, check if not in old)
for pmid in ${new_articles[@]+"${!new_articles[@]}"}; do
    if [[ -z "${old_articles[$pmid]:-}" ]]; then
        added_pmids+=("$pmid")
    fi
done

# Sort arrays numerically (handle empty arrays)
if [[ ${#added_pmids[@]} -gt 0 ]]; then
    mapfile -t added_pmids < <(printf '%s\n' "${added_pmids[@]}" | sort -n)
fi
if [[ ${#removed_pmids[@]} -gt 0 ]]; then
    mapfile -t removed_pmids < <(printf '%s\n' "${removed_pmids[@]}" | sort -n)
fi
if [[ ${#changed_pmids[@]} -gt 0 ]]; then
    mapfile -t changed_pmids < <(printf '%s\n' "${changed_pmids[@]}" | sort -n)
fi

# Counts
added_count=${#added_pmids[@]}
removed_count=${#removed_pmids[@]}
changed_count=${#changed_pmids[@]}
unchanged_count=${#unchanged_pmids[@]}

# Determine exit code
has_differences=false
if [[ $added_count -gt 0 ]] || [[ $removed_count -gt 0 ]] || [[ $changed_count -gt 0 ]]; then
    has_differences=true
fi

# =============================================================================
# Output
# =============================================================================

# Quiet mode - just set exit code
if [[ "$quiet" == true ]]; then
    if [[ "$has_differences" == true ]]; then
        exit 1
    else
        exit 0
    fi
fi

# Output based on format
case "$output_format" in
    summary)
        old_count=${#old_articles[@]}
        new_count=${#new_articles[@]}

        echo "OLD: $old_file ($old_count articles)"
        echo "NEW: $new_file ($new_count articles)"
        echo ""
        echo "  Added:     $added_count"
        echo "  Removed:   $removed_count"
        echo "  Changed:   $changed_count"
        echo "  Unchanged: $unchanged_count"
        echo ""
        total=$((old_count + added_count))
        echo "Total: $total unique PMIDs"
        ;;
    added)
        printf '%s\n' "${added_pmids[@]}"
        ;;
    removed)
        printf '%s\n' "${removed_pmids[@]}"
        ;;
    changed)
        printf '%s\n' "${changed_pmids[@]}"
        ;;
    all)
        # All different PMIDs (added + removed + changed)
        all_different=("${added_pmids[@]}" "${removed_pmids[@]}" "${changed_pmids[@]}")
        if [[ ${#all_different[@]} -gt 0 ]]; then
            mapfile -t all_different < <(printf '%s\n' "${all_different[@]}" | sort -n)
            printf '%s\n' "${all_different[@]}"
        fi
        ;;
    detailed)
        # Added articles
        if [[ $added_count -gt 0 ]]; then
            echo "=== ADDED ($added_count) ==="
            for pmid in "${added_pmids[@]}"; do
                title=$(echo "${new_articles[$pmid]}" | jq -r '.title // "No title"')
                echo "+ $pmid: $title"
            done
            echo ""
        fi

        # Removed articles
        if [[ $removed_count -gt 0 ]]; then
            echo "=== REMOVED ($removed_count) ==="
            for pmid in "${removed_pmids[@]}"; do
                title=$(echo "${old_articles[$pmid]}" | jq -r '.title // "No title"')
                echo "- $pmid: $title"
            done
            echo ""
        fi

        # Changed articles
        if [[ $changed_count -gt 0 ]]; then
            echo "=== CHANGED ($changed_count) ==="
            for pmid in "${changed_pmids[@]}"; do
                title=$(echo "${new_articles[$pmid]}" | jq -r '.title // "No title"')
                echo "~ $pmid: $title"

                # Find which fields changed
                old_json="${old_articles[$pmid]}"
                new_json="${new_articles[$pmid]}"

                # Get all keys from both
                all_keys=$(echo "$old_json" "$new_json" | jq -rs '.[0] * .[1] | keys[]' 2>/dev/null | sort -u)

                for key in $all_keys; do
                    old_val=$(echo "$old_json" | jq -r ".$key // null")
                    new_val=$(echo "$new_json" | jq -r ".$key // null")
                    if [[ "$old_val" != "$new_val" ]]; then
                        # Truncate long values for display
                        if [[ ${#old_val} -gt 50 ]]; then
                            old_val="${old_val:0:47}..."
                        fi
                        if [[ ${#new_val} -gt 50 ]]; then
                            new_val="${new_val:0:47}..."
                        fi
                        echo "    $key: \"$old_val\" -> \"$new_val\""
                    fi
                done
            done
            echo ""
        fi
        ;;
    jsonl)
        # Added articles
        for pmid in "${added_pmids[@]}"; do
            jq -c --arg pmid "$pmid" --argjson new "${new_articles[$pmid]}" \
                -n '{pmid: $pmid, status: "added", new: $new}'
        done

        # Removed articles
        for pmid in "${removed_pmids[@]}"; do
            jq -c --arg pmid "$pmid" --argjson old "${old_articles[$pmid]}" \
                -n '{pmid: $pmid, status: "removed", old: $old}'
        done

        # Changed articles
        for pmid in "${changed_pmids[@]}"; do
            old_json="${old_articles[$pmid]}"
            new_json="${new_articles[$pmid]}"

            # Find which fields changed
            diff_fields=()
            all_keys=$(echo "$old_json" "$new_json" | jq -rs '.[0] * .[1] | keys[]' 2>/dev/null | sort -u)

            for key in $all_keys; do
                old_val=$(echo "$old_json" | jq -c ".$key // null")
                new_val=$(echo "$new_json" | jq -c ".$key // null")
                if [[ "$old_val" != "$new_val" ]]; then
                    diff_fields+=("$key")
                fi
            done

            # Build diff array as JSON
            diff_json=$(printf '%s\n' "${diff_fields[@]}" | jq -R . | jq -s .)

            jq -c --arg pmid "$pmid" --argjson old "$old_json" --argjson new "$new_json" --argjson diff "$diff_json" \
                -n '{pmid: $pmid, status: "changed", old: $old, new: $new, diff: $diff}'
        done
        ;;
    *)
        echo "Error: Unknown format: $output_format" >&2
        exit 2
        ;;
esac

# Exit with appropriate code
if [[ "$has_differences" == true ]]; then
    exit 1
else
    exit 0
fi
