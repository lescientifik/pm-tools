#!/usr/bin/env bash
# pm-download - Download full-text PDFs from PubMed Central and Unpaywall
# Usage: pm-parse output | pm-download [OPTIONS]
#        pm-download [OPTIONS] < pmids.txt
#        pm-download [OPTIONS] --input pmids.txt

set -euo pipefail

# Source common functions
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck source=lib/pm-common.sh
source "${SCRIPT_DIR}/../lib/pm-common.sh"

# Check dependencies
require_commands curl jq

show_help() {
    cat << 'EOF'
pm-download - Download full-text PDFs from PubMed Central and Unpaywall

Usage:
  pm-parse output | pm-download [OPTIONS]
  pm-download [OPTIONS] < pmids.txt
  pm-download [OPTIONS] --input pmids.txt

Input Options:
  --input FILE         Read PMIDs from file (one per line)

Output Options:
  --output-dir DIR     Output directory (default: current directory)
  --overwrite          Overwrite existing files
  --dry-run            Show what would be downloaded, don't download

Download Options:
  --timeout SECS       Download timeout in seconds (default: 30)
  --email EMAIL        Email for Unpaywall API (required for Unpaywall)

Source Options:
  --pmc-only           Only use PMC (skip Unpaywall)
  --unpaywall-only     Only use Unpaywall (skip PMC)

General:
  -v, --verbose        Show progress on stderr
  -h, --help           Show this help message

Exit Codes:
  0 - All requested PDFs downloaded successfully
  1 - Usage error or some PDFs failed
  2 - No PDFs downloaded (no sources available)

Examples:
  # Download from pipeline
  pm-search "CRISPR" | pm-fetch | pm-parse | pm-download --output-dir ./pdfs/

  # Download with dry-run first
  pm-parse output.jsonl | pm-download --dry-run

  # Download from PMID list
  pm-download --input pmids.txt --email user@example.com
EOF
    exit 0
}

# Default values
OUTPUT_DIR="."
DRY_RUN=0
# shellcheck disable=SC2034 # Used in Phase 6 (download implementation)
OVERWRITE=0
# shellcheck disable=SC2034 # Used in Phase 6 (download implementation)
TIMEOUT=30
EMAIL=""
PMC_ONLY=0
UNPAYWALL_ONLY=0
VERBOSE=0
INPUT_FILE=""
MOCK_IDCONV=""  # For testing: path to mock ID converter response JSON
MOCK_PMC=""     # For testing: path to mock PMC OA Service response XML
MOCK_UNPAYWALL=""  # For testing: path to mock Unpaywall response JSON

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --help|-h)
            show_help
            ;;
        --verbose|-v)
            VERBOSE=1
            shift
            ;;
        --dry-run)
            DRY_RUN=1
            shift
            ;;
        --overwrite)
            OVERWRITE=1
            shift
            ;;
        --output-dir)
            OUTPUT_DIR="$2"
            shift 2
            ;;
        --timeout)
            TIMEOUT="$2"
            shift 2
            ;;
        --email)
            EMAIL="$2"
            shift 2
            ;;
        --input)
            INPUT_FILE="$2"
            shift 2
            ;;
        --pmc-only)
            PMC_ONLY=1
            shift
            ;;
        --unpaywall-only)
            UNPAYWALL_ONLY=1
            shift
            ;;
        --mock-idconv)
            MOCK_IDCONV="$2"
            shift 2
            ;;
        --mock-pmc)
            MOCK_PMC="$2"
            shift 2
            ;;
        --mock-unpaywall)
            MOCK_UNPAYWALL="$2"
            shift 2
            ;;
        *)
            die "Unknown option: $1. Use --help for usage."
            ;;
    esac
done

# Verbose logging
log_verbose() {
    if [[ "$VERBOSE" -eq 1 ]]; then
        echo "$@" >&2
    fi
}

# Determine input source
get_input() {
    if [[ -n "$INPUT_FILE" ]]; then
        if [[ ! -f "$INPUT_FILE" ]]; then
            die "Input file not found: $INPUT_FILE"
        fi
        cat "$INPUT_FILE"
    else
        cat
    fi
}

# Detect if input is JSONL or plain PMIDs
# Returns: "jsonl" or "pmid"
detect_input_format() {
    local first_line="$1"
    if [[ "$first_line" == "{"* ]]; then
        echo "jsonl"
    else
        echo "pmid"
    fi
}

# Extract fields from JSONL line
# Usage: extract_field "$json" "fieldname"
extract_field() {
    local json="$1"
    local field="$2"
    echo "$json" | jq -r ".$field // empty"
}

# Convert PMIDs to DOI/PMCID using NCBI ID Converter API
# Usage: convert_pmids "pmid1" "pmid2" ...
# Output: JSONL with pmid, pmcid, doi fields for each input PMID
convert_pmids() {
    local pmids=("$@")

    if [[ -n "$MOCK_IDCONV" ]]; then
        # Use mock response for testing
        if [[ -f "$MOCK_IDCONV" ]]; then
            # Extract records from mock JSON and output as JSONL
            jq -c '.records[]' "$MOCK_IDCONV"
        else
            log_verbose "Mock ID converter file not found: $MOCK_IDCONV"
        fi
        return
    fi

    # Real API call (batch up to 200 IDs)
    # Note: The ID Converter API requires a valid email format
    local api_email="${EMAIL:-user@example.com}"

    local batch_size=200
    local i=0
    while [[ $i -lt ${#pmids[@]} ]]; do
        local batch=("${pmids[@]:$i:$batch_size}")
        local ids_param
        ids_param=$(IFS=,; echo "${batch[*]}")

        log_verbose "Converting IDs: $ids_param"

        local response
        response=$(curl -s "https://pmc.ncbi.nlm.nih.gov/tools/idconv/api/v1/articles/?ids=${ids_param}&format=json&tool=pm-download&email=${api_email}")

        # Extract records from response
        echo "$response" | jq -c '.records[]' 2>/dev/null || true

        # Rate limit: 3 requests/second
        sleep 0.34

        i=$((i + batch_size))
    done
}

# Lookup PMID in converted data
# Usage: lookup_converted "$pmid" "$converted_data"
# Sets global variables: LOOKUP_PMCID, LOOKUP_DOI
lookup_converted() {
    local pmid="$1"
    local converted_data="$2"

    LOOKUP_PMCID=""
    LOOKUP_DOI=""

    # API returns pmid as number or string, so match either format
    local record
    record=$(echo "$converted_data" | grep -E "\"pmid\":(\"$pmid\"|$pmid)" | head -1)

    if [[ -n "$record" ]]; then
        LOOKUP_PMCID=$(echo "$record" | jq -r '.pmcid // empty')
        LOOKUP_DOI=$(echo "$record" | jq -r '.doi // empty')
    fi
}

# Query PMC OA Service for PDF URL
# Usage: pmc_lookup "$pmcid"
# Returns: PDF URL if available, empty if not
pmc_lookup() {
    local pmcid="$1"
    local response
    local pdf_url

    if [[ -n "$MOCK_PMC" ]]; then
        # Use mock response for testing
        if [[ -f "$MOCK_PMC" ]]; then
            response=$(cat "$MOCK_PMC")
        else
            log_verbose "Mock PMC file not found: $MOCK_PMC"
            return
        fi
    else
        # Real API call
        log_verbose "Querying PMC OA Service for $pmcid..."
        response=$(curl -s "https://www.ncbi.nlm.nih.gov/pmc/utils/oa/oa.fcgi?id=${pmcid}")

        # Rate limit
        sleep 0.34
    fi

    # Check for error
    if echo "$response" | grep -q "<error"; then
        log_verbose "PMC OA: $pmcid not in Open Access subset"
        return
    fi

    # Extract PDF URL from response
    # XML format: <link format="pdf" ... href="ftp://..."/>
    pdf_url=$(echo "$response" | grep -o 'format="pdf"[^>]*href="[^"]*"' | sed 's/.*href="\([^"]*\)".*/\1/' | head -1)

    if [[ -n "$pdf_url" ]]; then
        echo "$pdf_url"
    fi
}

# Query Unpaywall API for PDF URL
# Usage: unpaywall_lookup "$doi"
# Returns: PDF URL if available, empty if not
unpaywall_lookup() {
    local doi="$1"
    local response
    local pdf_url
    local is_oa

    if [[ -z "$EMAIL" ]]; then
        log_verbose "Unpaywall: --email required"
        return
    fi

    if [[ -n "$MOCK_UNPAYWALL" ]]; then
        # Use mock response for testing
        if [[ -f "$MOCK_UNPAYWALL" ]]; then
            response=$(cat "$MOCK_UNPAYWALL")
        else
            log_verbose "Mock Unpaywall file not found: $MOCK_UNPAYWALL"
            return
        fi
    else
        # Real API call
        # URL-encode the DOI (basic encoding for slashes)
        local encoded_doi
        encoded_doi="${doi//\//%2F}"

        log_verbose "Querying Unpaywall for $doi..."
        response=$(curl -s "https://api.unpaywall.org/v2/${encoded_doi}?email=${EMAIL}")

        # No rate limit needed for Unpaywall (100k/day is generous)
    fi

    # Check if OA
    is_oa=$(echo "$response" | jq -r '.is_oa // false')
    if [[ "$is_oa" != "true" ]]; then
        log_verbose "Unpaywall: $doi is not Open Access"
        return
    fi

    # Extract PDF URL from response
    pdf_url=$(echo "$response" | jq -r '.best_oa_location.url_for_pdf // empty')

    if [[ -n "$pdf_url" ]]; then
        echo "$pdf_url"
    else
        log_verbose "Unpaywall: $doi is OA but no PDF URL available"
    fi
}

# Process dry-run for a single article
# Returns: "available" or "unavailable"
process_dry_run() {
    local pmid="$1"
    local pmcid="$2"
    local doi="$3"
    local pdf_url=""

    # Try PMC first if we have PMCID and not --unpaywall-only
    if [[ "$UNPAYWALL_ONLY" -eq 0 && -n "$pmcid" ]]; then
        pdf_url=$(pmc_lookup "$pmcid")
        if [[ -n "$pdf_url" ]]; then
            echo "PMID $pmid: Would download from PMC ($pmcid) - PDF available"
            echo "available"
            return
        fi
        log_verbose "PMC: No PDF for $pmcid, trying fallback..."
    fi

    # Try Unpaywall if we have DOI and email (and not --pmc-only)
    if [[ "$PMC_ONLY" -eq 0 && -n "$doi" && -n "$EMAIL" ]]; then
        pdf_url=$(unpaywall_lookup "$doi")
        if [[ -n "$pdf_url" ]]; then
            echo "PMID $pmid: Would download via Unpaywall ($doi) - PDF available"
            echo "available"
            return
        fi
        log_verbose "Unpaywall: No PDF for $doi"
    fi

    # No source available
    if [[ -n "$doi" && -z "$EMAIL" ]]; then
        echo "PMID $pmid: Could download via Unpaywall ($doi) - requires --email"
    else
        echo "PMID $pmid: No source available (no DOI or PMCID)"
    fi
    echo "unavailable"
}

# Main processing
main() {
    local input
    local first_line
    local format
    local line_count=0
    local available_count=0
    local unavailable_count=0
    local converted_data=""

    # Read all input
    input=$(get_input)

    # Check for empty input
    if [[ -z "$input" ]]; then
        die "No input provided. Use --help for usage."
    fi

    # Detect format from first line
    first_line=$(echo "$input" | head -1)
    format=$(detect_input_format "$first_line")

    log_verbose "Input format detected: $format"

    # For PMID-only input, convert all PMIDs upfront
    if [[ "$format" == "pmid" ]]; then
        log_verbose "Converting PMIDs to get DOI/PMCID..."
        local pmids=()
        while IFS= read -r line; do
            [[ -z "$line" ]] && continue
            pmids+=("$line")
        done <<< "$input"

        if [[ ${#pmids[@]} -gt 0 ]]; then
            converted_data=$(convert_pmids "${pmids[@]}")
        fi
    fi

    # Create output directory if needed (unless dry-run)
    if [[ "$DRY_RUN" -eq 0 && ! -d "$OUTPUT_DIR" ]]; then
        mkdir -p "$OUTPUT_DIR"
    fi

    # Process each line
    while IFS= read -r line; do
        [[ -z "$line" ]] && continue

        local pmid="" pmcid="" doi=""

        if [[ "$format" == "jsonl" ]]; then
            pmid=$(extract_field "$line" "pmid")
            pmcid=$(extract_field "$line" "pmcid")
            doi=$(extract_field "$line" "doi")
        else
            # Plain PMID - look up in converted data
            pmid="$line"
            lookup_converted "$pmid" "$converted_data"
            pmcid="$LOOKUP_PMCID"
            doi="$LOOKUP_DOI"
        fi

        line_count=$((line_count + 1))

        if [[ "$DRY_RUN" -eq 1 ]]; then
            local result
            result=$(process_dry_run "$pmid" "$pmcid" "$doi")
            # Print all lines except the last (which is "available" or "unavailable")
            echo "$result" | head -n -1
            # Get the last line for counting
            local status_line
            status_line=$(echo "$result" | tail -1)
            if [[ "$status_line" == "available" ]]; then
                available_count=$((available_count + 1))
            else
                unavailable_count=$((unavailable_count + 1))
            fi
        else
            # Actual download (Phase 4-6)
            log_verbose "[$line_count] Processing PMID $pmid..."
            log_verbose "Options: output=$OUTPUT_DIR, overwrite=$OVERWRITE, timeout=$TIMEOUT"
            # TODO: Implement actual download
            echo "Download not yet implemented - use --dry-run"
            exit 1
        fi
    done <<< "$input"

    # Summary for dry-run
    if [[ "$DRY_RUN" -eq 1 ]]; then
        echo ""
        echo "Summary: $available_count available, $unavailable_count not available"
    fi

    # Exit codes
    if [[ "$available_count" -eq 0 ]]; then
        exit 2  # No sources available
    fi

    exit 0
}

main
